Table of Contents
-----------------

  * Simple Tests
    * Practice Quiz: Simple Tests <br>
        * `01_simple_tests.ipynb`
  * Unit Tests
    * Unit Tests: Practice Jupyter Notebook <br>
        * `02_unit_tests_and_edge_cases.ipynb`
  * Other Test Concepts
    * Practice Quiz: Other Test Concepts <br>
        * `03_other_test_concepts.ipynb`
  * Errors & Exceptions
    * Errors & Exceptions: Practice Notebook <br>
        * `04_errors_and_exceptions.ipynb`
  * Module Review
    * Qwiklabs Assessment: Implementing Unit Testing
      * `05_emails.py`
      * `05_emails_test.py` 

# Recap
## Version Control
- We can use a version control system to easily roll back your code to the previous version. Since you know that this version was working correctly before the change was made, it would be safe to go back to that one until you had time to fix the code, run some tests, and make sure everything works correctly for all machine models. 
- VCS are crucial to maintaining a healthy codebase for all kinds of IT resources, and for letting multiple people collaborate on the same coding projects together.

## Keeping Historical Copies
- The principle behind version control is the same. It lets us keep track of the changes in our files. These files can be code, images, configuration, or even a video editing project, whatever it is you're working with.

## Diffing Files
- We can use the `diff` command line tool to take two files or even to directories, and show the differences between them in a few formats. 
- Example:

    ```bash
    ┌──(kali㉿kali)-[~/Desktop/KI/Cryptography]
    └─$ diff caesar.py caesar2.py 
    8c8
    <     ciphertext += chr((ord(plaintext[i]) + 7 - 65) % 26 + 65)
    ---
    >     ciphertext -= chr((ord(plaintext[i]) + 7 - 65) % 26 + 65)

    ```

    The less than symbol tells us that the first line was removed from the first file, and the greater than symbol tells us that the second line was added to the second file. 
    
    The number at the beginning of this section indicates the line number in the first and second files. The c in between the numbers means that a line was changed. 
- Example using unified format:

    ```bash
    ┌──(kali㉿kali)-[~/Desktop/KI/Cryptography]
    └─$ diff -u caesar.py caesar2.py
    --- caesar.py   2021-03-04 20:28:04.854439153 -0500
    +++ caesar2.py  2021-03-09 03:52:16.031204735 -0500
    @@ -5,7 +5,7 @@
    
    for i in range(len(plaintext)):
    if(plaintext[i].isupper()):
    -    ciphertext += chr((ord(plaintext[i]) + 7 - 65) % 26 + 65)
    +    ciphertext -= chr((ord(plaintext[i]) + 7 - 65) % 26 + 65)
    else:
        ciphertext += chr((ord(plaintext[i]) + 7 - 97) % 26 + 97)
    ```

## Applying Changes
- The generated file from `diff` is usually referred to as a diff file or sometimes a patch file. It includes all the changes between the old file and the new one, plus the additional context needed to understand the changes and to apply those changes back to the original file.
- Patch takes a file generated by diff and applies the changes to the original file. Example:

    ```bash
    ┌──(kali㉿kali)-[~/Desktop/KI/Cryptography]
    └─$ patch caesar.py < caesar.diff                                                                                                                      1 ⨯
    patching file caesar.py
    ```
- By using a diff instead of the whole file, we can clearly see what they changed, no matter which version they were using. 
- The patch command can detect that there were changes made to the file and will do its best to apply the diff anyways. It won't always succeed but in many cases it will. Another reason is structure.

## 